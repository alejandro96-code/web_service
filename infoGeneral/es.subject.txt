Capítulo IV

Parte obligatoria
Nombre del programa webserv
Archivos a entregar Makefile, *.{h, hpp}, *.cpp, *.tpp, *.ipp,
archivos de configuración
Makefile NAME, all, clean, fclean, re
Argumentos [Un archivo de configuración]
Funciones externas Toda la funcionalidad debe implementarse en C++ 98.
execve, pipe, strerror, gai_strerror, errno, dup,
dup2, fork, socketpair, htons, htonl, ntohs, ntohl,
select, poll, epoll (epoll_create, epoll_ctl,
epoll_wait), kqueue (kqueue, kevent), socket,
accept, listen, send, recv, chdir, bind, connect,
getaddrinfo, freeaddrinfo, setsockopt, getsockname,
getprotobyname, fcntl, close, read, write, waitpid,
kill, signal, access, stat, open, opendir, readdir
y closedir.
Libft autorizada n/a
Descripción Un servidor HTTP en C++ 98

Debes escribir un servidor HTTP en C++ 98.

Tu ejecutable debe ejecutarse de la siguiente manera:
./webserv [archivo de configuración]

Aunque poll() se menciona en el enunciado y la hoja de evaluación, puedes usar cualquier función equivalente como select(), kqueue(), o
epoll().

Por favor, lee los RFCs que definen el protocolo HTTP, y realiza pruebas con telnet y NGINX antes de comenzar este proyecto.
Aunque no es necesario implementar los RFCs completos, su lectura te ayudará a desarrollar las características requeridas.
El HTTP 1.0 se sugiere como punto de referencia, pero no es obligatorio.

IV.1 Requisitos

• Tu programa debe usar un archivo de configuración, proporcionado como argumento en la línea de comandos,o disponible en una ruta predeterminada.
• No puedes hacer execve de otro servidor web.
• Tu servidor debe permanecer no bloqueante en todo momento y manejar correctamente las desconexiones de clientes cuando sea necesario.
• Debe ser no bloqueante y usar solo 1 poll() (o equivalente) para todas las operaciones de E/S entre los clientes y el servidor (listen incluido).
• poll() (o equivalente) debe monitorear tanto lectura como escritura simultáneamente.
• Nunca debes realizar una operación de lectura o escritura sin pasar por poll() (o equivalente).
• Está estrictamente prohibido comprobar el valor de errno para ajustar el comportamiento del servidor después de realizar una operación de lectura o escritura.
• No es necesario usar poll() (o una función equivalente) para archivos regulares de disco;
read() y write() en ellos no requieren notificaciones de disponibilidad.

Las E/S que pueden esperar datos (sockets, pipes/FIFOs, etc.) deben ser
no bloqueantes y dirigidas por un único poll() (o equivalente). Llamar a
read/recv o write/send en estos descriptores sin disponibilidad previa
resultará en una calificación de 0. Los archivos regulares de disco están exentos.

• Al usar poll() o cualquier llamada equivalente, puedes usar cada macro asociado o
función auxiliar (por ejemplo, FD_SET para select()).
• Una solicitud a tu servidor nunca debe quedarse colgada indefinidamente.
• Tu servidor debe ser compatible con navegadores web estándar de tu elección.
• NGINX puede usarse para comparar cabeceras y comportamientos de respuesta (presta atención
a las diferencias entre versiones HTTP).
• Tus códigos de estado de respuesta HTTP deben ser precisos.
• Tu servidor debe tener páginas de error predeterminadas si no se proporcionan.
• No puedes usar fork para nada más que CGI (como PHP, Python, etc.).
• Debes poder servir un sitio web completamente estático.
• Los clientes deben poder subir archivos.
• Necesitas al menos los métodos GET, POST y DELETE
• Realiza pruebas de estrés en tu servidor para asegurar que permanece disponible en todo momento.
• Tu servidor debe poder escuchar en múltiples puertos para entregar contenido diferente
(ver archivo de configuración).

Deliberadamente elegimos ofrecer solo un subconjunto del RFC HTTP. En este
contexto, la característica de host virtual se considera fuera del alcance. Pero
puedes implementarla si quieres.

IV.3 Archivo de configuración
Puedes inspirarte en la sección 'server' del archivo de configuración de NGINX.

En el archivo de configuración, debes poder:
• Definir todos los pares interfaz:puerto en los que tu servidor escuchará (definiendo múltiples sitios web servidos por tu programa).
• Configurar páginas de error predeterminadas.
• Establecer el tamaño máximo permitido para los cuerpos de solicitud del cliente.
• Especificar reglas o configuraciones en una URL/ruta (no se requiere regex aquí), para un
sitio web, entre las siguientes:
◦ Lista de métodos HTTP aceptados para la ruta.
◦ Redirección HTTP.
◦ Directorio donde se debe localizar el archivo solicitado (por ejemplo, si la URL /kapouet
está enraizada en /tmp/www, la URL /kapouet/pouic/toto/pouet buscará
/tmp/www/pouic/toto/pouet).
◦ Habilitar o deshabilitar el listado de directorios.
◦ Archivo predeterminado a servir cuando el recurso solicitado es un directorio.
◦ Se autoriza la subida de archivos desde los clientes al servidor, y se proporciona la ubicación
de almacenamiento.
◦ Ejecución de CGI, basada en la extensión del archivo (por ejemplo .php). Aquí hay algunas
observaciones específicas sobre CGI:
∗ ¿Te preguntas qué es un CGI?
∗ Observa cuidadosamente las variables de entorno involucradas en la comunicación
servidor web-CGI. La solicitud completa y los argumentos proporcionados por
el cliente deben estar disponibles para el CGI.
∗ Recuerda que, para solicitudes fragmentadas (chunked), tu servidor necesita des-fragmentarlas,
el CGI esperará EOF como el final del cuerpo.
∗ Lo mismo aplica a la salida del CGI. Si no se devuelve content_length desde
el CGI, EOF marcará el final de los datos devueltos.
∗ El CGI debe ejecutarse en el directorio correcto para el acceso a archivos de ruta relativa.

Tu servidor debe soportar al menos un CGI (php-CGI, Python, etc.).

Debes proporcionar archivos de configuración y archivos predeterminados para probar y demostrar que
cada característica funciona durante la evaluación.

Puedes tener otras reglas o información de configuración en tu archivo (por ejemplo, un nombre de servidor
para un sitio web si planeas implementar hosts virtuales).

Si tienes alguna pregunta sobre un comportamiento específico, puedes comparar
el comportamiento de tu programa con el de NGINX.
Hemos proporcionado un pequeño tester. Usarlo no es obligatorio si
todo funciona bien con tu navegador y pruebas, pero puede ayudarte
a encontrar y corregir errores.

La resiliencia es clave. Tu servidor debe permanecer operativo en todo momento.

No pruebes solo con un programa. Escribe tus pruebas en un lenguaje más
adecuado, como Python o Golang, entre otros, incluso
en C o C++ si lo prefieres.