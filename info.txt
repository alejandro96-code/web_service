Capítulo IV

Parte obligatoria
Nombre del programa webserv
Archivos a entregar Makefile, *.{h, hpp}, *.cpp, *.tpp, *.ipp,
archivos de configuración
Makefile NAME, all, clean, fclean, re
Argumentos [Un archivo de configuración]
Funciones externas Toda la funcionalidad debe implementarse en C++ 98.
execve, pipe, strerror, gai_strerror, errno, dup,
dup2, fork, socketpair, htons, htonl, ntohs, ntohl,
select, poll, epoll (epoll_create, epoll_ctl,
epoll_wait), kqueue (kqueue, kevent), socket,
accept, listen, send, recv, chdir, bind, connect,
getaddrinfo, freeaddrinfo, setsockopt, getsockname,
getprotobyname, fcntl, close, read, write, waitpid,
kill, signal, access, stat, open, opendir, readdir
y closedir.
Libft autorizada n/a
Descripción Un servidor HTTP en C++ 98

Debes escribir un servidor HTTP en C++ 98.

Tu ejecutable debe ejecutarse de la siguiente manera:
./webserv [archivo de configuración]

Aunque poll() se menciona en el enunciado y la hoja de evaluación, puedes usar cualquier función equivalente como select(), kqueue(), o
epoll().

Por favor, lee los RFCs que definen el protocolo HTTP, y realiza pruebas con telnet y NGINX antes de comenzar este proyecto.
Aunque no es necesario implementar los RFCs completos, su lectura te ayudará a desarrollar las características requeridas.
El HTTP 1.0 se sugiere como punto de referencia, pero no es obligatorio.

IV.1 Requisitos

• Tu programa debe usar un archivo de configuración, proporcionado como argumento en la línea de comandos,o disponible en una ruta predeterminada.
• No puedes hacer execve de otro servidor web.
• Tu servidor debe permanecer no bloqueante en todo momento y manejar correctamente las desconexiones de clientes cuando sea necesario.
• Debe ser no bloqueante y usar solo 1 poll() (o equivalente) para todas las operaciones de E/S entre los clientes y el servidor (listen incluido).
• poll() (o equivalente) debe monitorear tanto lectura como escritura simultáneamente.
• Nunca debes realizar una operación de lectura o escritura sin pasar por poll() (o equivalente).
• Está estrictamente prohibido comprobar el valor de errno para ajustar el comportamiento del servidor después de realizar una operación de lectura o escritura.
• No es necesario usar poll() (o una función equivalente) para archivos regulares de disco;
read() y write() en ellos no requieren notificaciones de disponibilidad.

Las E/S que pueden esperar datos (sockets, pipes/FIFOs, etc.) deben ser
no bloqueantes y dirigidas por un único poll() (o equivalente). Llamar a
read/recv o write/send en estos descriptores sin disponibilidad previa
resultará en una calificación de 0. Los archivos regulares de disco están exentos.

• Al usar poll() o cualquier llamada equivalente, puedes usar cada macro asociado o
función auxiliar (por ejemplo, FD_SET para select()).
• Una solicitud a tu servidor nunca debe quedarse colgada indefinidamente.
• Tu servidor debe ser compatible con navegadores web estándar de tu elección.
• NGINX puede usarse para comparar cabeceras y comportamientos de respuesta (presta atención
a las diferencias entre versiones HTTP).
• Tus códigos de estado de respuesta HTTP deben ser precisos.
• Tu servidor debe tener páginas de error predeterminadas si no se proporcionan.
• No puedes usar fork para nada más que CGI (como PHP, Python, etc.).
• Debes poder servir un sitio web completamente estático.
• Los clientes deben poder subir archivos.
• Necesitas al menos los métodos GET, POST y DELETE
• Realiza pruebas de estrés en tu servidor para asegurar que permanece disponible en todo momento.
• Tu servidor debe poder escuchar en múltiples puertos para entregar contenido diferente
(ver archivo de configuración).

Deliberadamente elegimos ofrecer solo un subconjunto del RFC HTTP. En este
contexto, la característica de host virtual se considera fuera del alcance. Pero
puedes implementarla si quieres.

IV.3 Archivo de configuración
Puedes inspirarte en la sección 'server' del archivo de configuración de NGINX.

En el archivo de configuración, debes poder:
• Definir todos los pares interfaz:puerto en los que tu servidor escuchará (definiendo múltiples sitios web servidos por tu programa).
• Configurar páginas de error predeterminadas.
• Establecer el tamaño máximo permitido para los cuerpos de solicitud del cliente.
• Especificar reglas o configuraciones en una URL/ruta (no se requiere regex aquí), para un
sitio web, entre las siguientes:
◦ Lista de métodos HTTP aceptados para la ruta.
◦ Redirección HTTP.
◦ Directorio donde se debe localizar el archivo solicitado (por ejemplo, si la URL /kapouet
está enraizada en /tmp/www, la URL /kapouet/pouic/toto/pouet buscará
/tmp/www/pouic/toto/pouet).
◦ Habilitar o deshabilitar el listado de directorios.
◦ Archivo predeterminado a servir cuando el recurso solicitado es un directorio.
◦ Se autoriza la subida de archivos desde los clientes al servidor, y se proporciona la ubicación
de almacenamiento.
◦ Ejecución de CGI, basada en la extensión del archivo (por ejemplo .php). Aquí hay algunas
observaciones específicas sobre CGI:
∗ ¿Te preguntas qué es un CGI?
∗ Observa cuidadosamente las variables de entorno involucradas en la comunicación
servidor web-CGI. La solicitud completa y los argumentos proporcionados por
el cliente deben estar disponibles para el CGI.
∗ Recuerda que, para solicitudes fragmentadas (chunked), tu servidor necesita des-fragmentarlas,
el CGI esperará EOF como el final del cuerpo.
∗ Lo mismo aplica a la salida del CGI. Si no se devuelve content_length desde
el CGI, EOF marcará el final de los datos devueltos.
∗ El CGI debe ejecutarse en el directorio correcto para el acceso a archivos de ruta relativa.

Tu servidor debe soportar al menos un CGI (php-CGI, Python, etc.).

Debes proporcionar archivos de configuración y archivos predeterminados para probar y demostrar que
cada característica funciona durante la evaluación.

Puedes tener otras reglas o información de configuración en tu archivo (por ejemplo, un nombre de servidor
para un sitio web si planeas implementar hosts virtuales).

Si tienes alguna pregunta sobre un comportamiento específico, puedes comparar
el comportamiento de tu programa con el de NGINX.
Hemos proporcionado un pequeño tester. Usarlo no es obligatorio si
todo funciona bien con tu navegador y pruebas, pero puede ayudarte
a encontrar y corregir errores.

La resiliencia es clave. Tu servidor debe permanecer operativo en todo momento.

No pruebes solo con un programa. Escribe tus pruebas en un lenguaje más
adecuado, como Python o Golang, entre otros, incluso
en C o C++ si lo prefieres.

IV.1 Requirements
• Your program must use a configuration file, provided as an argument on the command line, or available in a default path.
• You cannot execve another web server.
• Your server must remain non-blocking at all times and properly handle client disconnections when necessary.
• It must be non-blocking and use only 1 poll() (or equivalent) for all the I/O
operations between the clients and the server (listen included).
• poll() (or equivalent) must monitor both reading and writing simultaneously.
• You must never do a read or a write operation without going through poll() (or
equivalent).
• Checking the value of errno to adjust the server behaviour is strictly forbidden
after performing a read or write operation.
• You are not required to use poll() (or an equivalent function) for regular disk files;
read() and write() on them do not require readiness notifications.

I/O that can wait for data (sockets, pipes/FIFOs, etc.) must be
non-blocking and driven by a single poll() (or equivalent). Calling
read/recv or write/send on these descriptors without prior readiness
will result in a grade of 0. Regular disk files are exempt.

• When using poll() or any equivalent call, you can use every associated macro or
helper function (e.g., FD_SET for select()).
• A request to your server should never hang indefinitely.
• Your server must be compatible with standard web browsers of your choice.
• NGINX may be used to compare headers and answer behaviours (pay attention to
differences between HTTP versions).
• Your HTTP response status codes must be accurate.
• Your server must have default error pages if none are provided.
• You can’t use fork for anything other than CGI (like PHP, or Python, and so forth).
• You must be able to serve a fully static website.
• Clients must be able to upload files.
• You need at least the GET, POST, and DELETE methods
• Stress test your server to ensure it remains available at all times.
• Your server must be able to listen to multiple ports to deliver different content (see
Configuration file).

We deliberately chose to offer only a subset of the HTTP RFC. In this
context, the virtual host feature is considered out of scope. But
you are allowed to implement it if you want.

IV.3 Configuration file
You can take inspiration from the ’server’ section of the NGINX
configuration file.

In the configuration file, you should be able to:
• Define all the interface:port pairs on which your server will listen to (defining multiple websites served by your program).
• Set up default error pages.
• Set the maximum allowed size for client request bodies.
• Specify rules or configurations on a URL/route (no regex required here), for a
website, among the following:
◦ List of accepted HTTP methods for the route.
◦ HTTP redirection.
◦ Directory where the requested file should be located (e.g., if URL /kapouet
is rooted to /tmp/www, URL /kapouet/pouic/toto/pouet will search for
/tmp/www/pouic/toto/pouet).
◦ Enabling or disabling directory listing.
◦ Default file to serve when the requested resource is a directory.
◦ Uploading files from the clients to the server is authorized, and storage location
is provided.
◦ Execution of CGI, based on file extension (for example .php). Here are some
specific remarks regarding CGIs:
∗ Do you wonder what a CGI is?
∗ Have a careful look at the environment variables involved in the web
server-CGI communication. The full request and arguments provided by
the client must be available to the CGI.
∗ Just remember that, for chunked requests, your server needs to un-chunk
them, the CGI will expect EOF as the end of the body.
∗ The same applies to the output of the CGI. If no content_length is
returned from the CGI, EOF will mark the end of the returned data.
∗ The CGI should be run in the correct directory for relative path file access.

Your server should support at least one CGI (php-CGI, Python, and so
forth).

You must provide configuration files and default files to test and demonstrate that
every feature works during the evaluation.

You can have other rules or configuration information in your file (e.g., a server name
for a website if you plan to implement virtual hosts).

If you have a question about a specific behaviour, you can compare
your program’s behaviour with NGINX’s.
We have provided a small tester. Using it is not mandatory if
everything works fine with your browser and tests, but it can help
you find and fix bugs.

Resilience is key. Your server must remain operational at all times.

Do not test with only one program. Write your tests in a more
suitable language, such as Python or Golang, among others, even
in C or C++ if you prefer.